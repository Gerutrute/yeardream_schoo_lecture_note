![image](https://github.com/user-attachments/assets/049636ba-8f40-41d0-8997-060262eeb3a8)# 알고리즘을 배우는 이유
- 하드웨어를 최적의 알고리즘 설계를 통해 시간복잡도를 줄여서
적은 비용 대비 높은 효과를 보기 위함. 기업에서도 선호함.

## 시간복잡도
### 자료구조
- 데이터를 효율적으로 저장하고 조직하는 방법 -> 구조 중심

### 알고리즘
- 문제를 해결하기 위한 명확한 절차나 방법 -> 로직 중심

## 자료구조 vs 알고리즘

| 자료구조                         | 알고리즘                         |
|----------------------------------|----------------------------------|
| "무엇을 저장할까?"              | "어떻게 빠르게 처리할까?"              |
| 정리된 **데이터의 그릇**         | 정해진 **절차나 흐름**           |
| 예: 배열, 스택, 큐, 트리        | 예: 정렬, 탐색, 최단 경로        |

| 항목   | 자료구조                 | 알고리즘                   |
|--------|--------------------------|----------------------------|
| 초점   | 데이터 저장              | 데이터 처리                |
| 역할   | 효율적인 데이터 접근     | 문제 해결 절차             |
| 예     | 배열, 큐, 트리           | 정렬, 탐색, 경로 탐색      |
| 관계   | 알고리즘의 기반          | 자료구조들 활용            |

시간 복잡도

## 빅오표기법
- **알고리즘의 효율성(시간이나 공간 사용량)**을 분석할 때 사용되는 수학적 표기법
예: 입력이 10,000개면 `O(n^2)`은 느릴 수 있으므로 `O(n log n)` 이하로 설계 권장
| 시간 복잡도       | 설명                                                         | 예시                             |
|------------------|--------------------------------------------------------------|----------------------------------|
| O(1)             | 상수 시간 - 입력 크기와 무관하게 항상 일정한 연산             |                                  |
| O(log n)         | 로그 시간 - 이진 탐색 등이 여기에 해당                        | 이진 탐색 등                     |
| O(n)             | 선형 시간 - 한 번씩 모든 데이터를 보는 경우                   |                                  |
| O(n log n)       | 선형 로그 시간 - 효율적인 정렬 알고리즘                       | Merge Sort 등                    |
| O(n²)            | 이차 시간 - 이중 반복문                                       | 버블 소트 등                     |
| O(2ⁿ), O(n!)     | 지수 및 팩토리얼 시간 - 재귀, 백트래킹 문제                   | 체스, 백트래킹 문제 등           |
⁂O(1)은 1초

![image](https://github.com/user-attachments/assets/e8e2a7f4-9ef2-4fd3-8923-d4d0c04e2aee)


대표적인 Big-O 표기법의 종류
![image](https://github.com/user-attachments/assets/4f097a94-2360-48f0-838e-286a3644d8fa)

### O(1)

- **일정한 복잡도** (*constant complexity*)
- 입력값이 증가하더라도 **실행 시간이 늘어나지 않음**
- 👉 입력값의 크기와 **관계없이**, 즉시 출력값을 얻어낼 수 있음

#### 📌 예시
- 어떤 배열의 특정 인덱스 위치의 요소 출력
![image](https://github.com/user-attachments/assets/3ec7ff3b-6473-4b22-ab9f-d2bc6bc8d2eb)

![image](https://github.com/user-attachments/assets/dfe81581-70da-4cd4-8bd1-67677a081376)

### 🔍 O(log N)
로그 복잡도 (logarithmic complexity)

시간 복잡도는
O(1) < O(log N) < O(N) 순으로 큼
N이 커질수록 O(N)보다 O(1)에 더 가까워짐

탐색 범위의 중간값을 제시할 때마다 경우의 수가 절반씩 줄어듦
🎯 특정 숫자를 맞추는 Up & Down 게임
매 시도마다 탐색 범위가 절반으로 줄어드는 방식

## 🔍 선형 탐색(Linear Search) vs 이진 탐색(Binary Search)

| 항목             | 🔸 선형 탐색 (Linear Search)          | 🔹 이진 탐색 (Binary Search)                    |
|------------------|----------------------------------------|-------------------------------------------------|
| **탐색 방식**     | 왼쪽부터 하나씩 전부 확인             | 중앙값과 비교 → 절반씩 범위 줄이기              |
| **정렬 필요 여부**| ❌ 정렬 불필요                         | ✅ 반드시 오름차순 정렬 필요                    |
| **시간 복잡도**   | O(n) (최악의 경우 전부 탐색)          | O(log n) (절반씩 나눔)                           |
| **공간 복잡도**   | O(1)                                   | O(1) (반복형), O(log n) (재귀형)                |
| **최선의 경우**   | O(1) (첫 번째에서 찾으면)             | O(1) (중앙에서 찾으면)                           |
| **구현 난이도**   | 매우 쉬움                              | 중간값, 범위 관리가 필요 → 조금 더 복잡         |
| **데이터 크기**   | 작을 때 적합                           | 데이터가 크고 정렬되어 있을 때 효과적            |
| **결과 보장**     | 항상 결과 탐색 가능                    | 정렬 안 되어 있으면 ❌ 사용 불가                 |

---

### 📈 시간 복잡도 비교

> **빠름**  
> `O(1)` < `O(log n)` < `O(n)` < `O(n log n)` < **느림**  
> `O(n²)` < `O(n³)` < `O(2ⁿ)` < `O(n!)`

## 로그 복잡도와 이진 탐색

![image](https://github.com/user-attachments/assets/0a116226-e6d0-41d6-bbc7-204dcf19da45)

![image](https://github.com/user-attachments/assets/7ff9e4fc-c2ed-4190-bf7b-c105d05eb9a1)

## 로그 복잡도와 선형 탐색

![image](https://github.com/user-attachments/assets/c1d35c98-0084-4993-801d-c2a43d5a7100)

![image](https://github.com/user-attachments/assets/8c57ab11-7bcf-437d-99e2-3fd95cb7f605)

## 2차 복잡도

![image](https://github.com/user-attachments/assets/e0ffa007-6cfd-47e3-b75d-01c8db5a9096)

### 2차 복잡도 예제
![image](https://github.com/user-attachments/assets/0925bdfd-293a-4c07-91a1-42051d7bb35d)
SQL의 cross join 과 유사

![image](https://github.com/user-attachments/assets/16555a88-e0af-40f7-9e57-0e7ed53936f8)

## 팩토리얼

![image](https://github.com/user-attachments/assets/01f446dd-bccc-411f-8d7d-6b26c130776a)

## 🔢 순열(Permutation) vs 조합(Combination)

| 항목       | 순열 (Permutation)                  | 조합 (Combination)                       |
|------------|--------------------------------------|------------------------------------------|
| **의미**   | 순서를 고려하여 뽑기                 | 순서를 고려하지 않고 뽑기                |
| **기호**   | P(n, r) 또는 nPr                    | C(n, r) 또는 nCr                         |
| **공식**   | n! / (n - r)!                        | n! / (r! * (n - r)!)                      |
| **중복 여부**| 같은 숫자라도 **순서가 다르면 다른 경우로 셈** | 순서가 달라도 **같은 조합은 한 번만 셈**     |
| **예시**   | A, B, C 중 2개를 순열: AB, BA, AC, CA, BC, CB → 6개 | A, B, C 중 2개를 조합: AB, AC, BC → 3개 |
| **활용**   | 좌석 배치, 비밀번호, 경로 문제        | 팀 구성, 로또 번호, 부분 집합             |
| **시간복잡도**| O(n!) (완전탐색 시)                | O(nCr) 또는 O(2ⁿ) (모든 조합 탐색 시)     |

![image](https://github.com/user-attachments/assets/507ca401-61ff-4049-bb2d-fd61ded2508d)

## 완전탐색

![image](https://github.com/user-attachments/assets/440cbc90-2505-4fd4-ab38-42db8f218d8e)

![image](https://github.com/user-attachments/assets/e191f473-197b-41f6-a860-f7b0831cd3b0)

![image](https://github.com/user-attachments/assets/6254e922-7dca-43a8-bf90-81edf4368e97)

## 🔃 정렬 알고리즘 비교 (평균 시간복잡도 기준)

| 이름         | 평균 시간복잡도                      | 특징                         |
|--------------|---------------------------------------|------------------------------|
| 버블 정렬     | O(n²)                                 | 가장 기본, 인접 교환         |
| 선택 정렬     | O(n²)                                 | 최소값을 선택                |
| 삽입 정렬     | O(n²)                                 | 정렬된 부분에 삽입           |
| 병합 정렬     | O(n log n)                            | 분할 정복 기반               |
| 퀵 정렬       | O(n log n) (평균) / O(n²) (최악)     | 가장 널리 사용               |

# 유클리드 호제법
- **정의**  
  최대공약수 및 최소공배수를 빠르게 구하기 위해 알아야 하는 핵심 알고리즘의 기본 원리

- **이유**  
  - 빠른 속도의 연산 `O(log n)`이 가능  
  - 수학 알고리즘 솔루션 및 알고리즘 분석에 유용

- **예시**
  - **최소공배수 계산** → 시간 동기화, 주기적 이벤트 출력 알고리즘
  - **기약분수 계산** → 계산기 연산, 수식 처리 연산 알고리즘
  - **최소공배수 → RSA 알고리즘**, 오일러 함수, HTTPS 통신, 블록체인 서명, 보안 토큰 등

## 📐 유클리드 기하 활용 예시

| 분야             | 유클리드 기하 적용 예시            | 관련 개념                    |
|------------------|------------------------------------|------------------------------|
| 로봇 경로 탐색   | 최단 거리 계산, 장애물 회피        | 점, 선, 거리                 |
| 컴퓨터 비전      | 객체 위치/자세 측정                | 도형, 각도, 삼각형           |
| 로봇 팔 제어     | 관절 각도 계산                     | 삼각형, 코사인 법칙          |
| 자율주행, SLAM   | 지도 작성, 위치 추적               | 거리, 각도                   |
| 머신러닝         | 벡터 간 거리 계산                  | 유클리드 거리                |

## 📐 최대공약수(GCD) 및 관련 연산 예시

| 유형              | 예시 문제                                                         |
|-------------------|-------------------------------------------------------------------|
| **최대공약수**     | `gcd(a, b)`                                                      |
| **최소공배수**     | `lcm(a, b) = a * b // gcd(a, b)`                                  |
| **기약 분수**      | `a / b = (a ÷ gcd(a, b)) / (b ÷ gcd(a, b))`                        |
| **여러 수의 공약수**| 배열 전체의 GCD (`reduce(gcd, [a1, a2, ..., an])`) 등으로 표현 가능 |
| **서로소 판별**    | `gcd(a, b) == 1`            |

![image](https://github.com/user-attachments/assets/a767cbdd-09f4-48ea-9ebc-63023e620b2c)

![image](https://github.com/user-attachments/assets/bb19735e-9c6b-4640-b1e8-a9d14630d3d2)

![image](https://github.com/user-attachments/assets/f061af7a-16ae-4c99-a843-e2127012d09b)

![image](https://github.com/user-attachments/assets/d1b334dc-7879-4d88-96fc-8e54e4fd0c0e)

# 소수 판별법

![image](https://github.com/user-attachments/assets/a3721abf-0e90-4caf-8b31-6283a9414cab)

## 🔍 소수 판별 알고리즘이 중요한 이유

| 이유           | 설명                                                                 |
|----------------|----------------------------------------------------------------------|
| **문제 조건**   | 소수인지 아닌지를 빠르게 판단해야 함                                 |
| **시간 효율**   | 무식하게 나누면 시간 초과 발생 → `O(√n)` or `O(n log log n)` 필요     |
| **알고리즘 기반**| 소수는 수학적 구조에서 자주 쓰임 (약수, 분해, 암호학 등)              |
| **반복 사용**   | 대량의 수에 대해 반복적으로 검사해야 하는 경우 많음                   |

## 🔐 소수 판별 알고리즘의 활용 분야

| 분야                 | 소수 판별 사용 이유                           | 예시                        |
|----------------------|-----------------------------------------------|-----------------------------|
| **보안 암호화**        | RSA 키 생성 시 소수 검증                       | AI 인증, 데이터 보호        |
| **하이퍼파라미터 튜닝**| 광학유 효피, 구조 단순화 *(ex: 필터 수 = 소수)* | 필터 수 = 소수              |
| **난수 생성**         | 난수 품질 향상                                 | 강화학습 시드 고정          |
| **수학 문제 AI**       | 소수 여부 판단 + 이론 활용                    | GPT, Wolfram                |
| **진화 알고리즘**      | mod 연산 기반 최적화                          | 유전적 알고리즘             |

![image](https://github.com/user-attachments/assets/db043aed-12fd-473d-8303-364685a0bb00)

# 회문

![image](https://github.com/user-attachments/assets/e1b66c00-5192-47a3-90d7-2a301690bd1f)

![image](https://github.com/user-attachments/assets/f014936b-516e-4548-ba47-51754c83e6af)

## ⚠️ Python 주요 예외 클래스 정리

| 예외 클래스           | 설명 (언제 발생?)                                   |
|------------------------|----------------------------------------------------|
| `ZeroDivisionError`    | 0으로 나눌 때 (`10 / 0`)                            |
| `ValueError`           | 자료형 변환 실패 (`int("hello")`)                  |
| `TypeError`            | 자료형이 맞지 않을 때 (`"abc" + 123`)             |
| `NameError`            | 존재하지 않는 변수를 사용할 때 (`print(x)` → x 미정의) |
| `IndexError`           | 인덱스 범위 초과 (`list[10]`에서 리스트 길이 5일 경우) |
| `KeyError`             | 딕셔너리에 없는 키 접근 시 (`my_dict["없는키"]`)                    |
| `FileNotFoundError`    | 없는 파일 열기 시도 (`open("없는파일.txt")`)                         |
| `IOError`              | 입출력 에러 (파일, 디바이스 오류 포함)                             |
| `AttributeError`       | 없는 속성에 접근 (`None.upper()`)                                  |
| `ImportError`          | 모듈 임포트 실패 (`import 잘못된모듈`)                             |
| `RuntimeError`         | 일반 실행 중 오류                                                  |
| `IndentationError`     | 들여쓰기 오류                                                      |
| `SyntaxError`          | 문법 오류 (`if True print("hi")`)                                  |

