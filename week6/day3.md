# 기초 알고리즘

![image](https://github.com/user-attachments/assets/466269fe-b5cd-4d49-ac67-17b187463b3e)

![image](https://github.com/user-attachments/assets/4e991210-2c32-449b-b058-b7270070f1de)

### 조합 (Combination) vs 순열 (Permutation) 비교

| 구분                      | 조합 (Combination)                           | 순열 (Permutation)                          |
|-------------------------|--------------------------------------------|--------------------------------------------|
| **순서**                  | ❌ 무시함                                     | ✅ 고려함                                     |
| **중복**                  | 없음                                         | 없음                                         |
| **공식**                  | \({}_nC_r = \dfrac{n!}{r!\,(n-r)!}\)         | \({}_nP_r = \dfrac{n!}{(n-r)!}\)             |
| **예시 (3개 중 2개 선택)** | AB, AC, BC                                  | AB, AC, BA, BC, CA, CB                       |

---

### 상황별 조합 vs 순열

| 상황                                                    | 조합인가요? | 순열인가요? |
|-------------------------------------------------------|:---------:|:---------:|
| 로또 번호 선택 (순서 무시)                                | ✅         |           |
| 달리기 순위 정하기 (1등, 2등, 3등 — 순서 중요)             |           | ✅         |
| 시험지에서 3문제를 뽑아 푸는 경우 (문제 순서 상관없음)        | ✅         |           |
| 비밀번호 자리 배치 (순서 중요)                             |           | ✅         |

## 완전탐색과 그리디

![image](https://github.com/user-attachments/assets/0e27aeff-7d46-4431-b158-7ed363f7ca82)

### 1. 완전탐색 (Brute Force)

- **정의**  
  모든 경우의 수를 빠짐없이 전부 시도해서 정답을 찾는 방식  
  → “답이 나올 때까지 전부 다 해보자!”

- **특징**  
  - 가장 직관적이고 단순한 접근법  
  - 정확한 결과를 보장  
  - 경우의 수가 많아지면 비효율적(느림)

- **시간 복잡도**  
  보통 매우 높음  
  - O(n^2)  
  - O(2^n)  
  - O(n!) 등

### 2. 그리디 (Greedy)

- **정의**  
  매 순간 최선의 선택(가장 좋아 보이는 선택)을 하면서 정답에 접근하는 방식  
  → “지금 당장 최고를 선택!”

- **특징**  
  - 빠르고 간단하며 효율적  
  - 항상 정답을 보장하지는 않음 (문제 구조에 따라)  
  - 문제에 ‘탐욕 조건’이 성립해야 사용 가능

- **시간 복잡도**  
  보통 매우 낮음  
  - O(n)  
  - O(1) 등

| 방식                         | 탐색 전략           | 시간 복잡도 | 특징                           |
|----------------------------|--------------------|----------|------------------------------|
| 완전탐색 (Brute Force)      | 모든 수 탐색         | O(n²)     | 정확하지만 비효율적             |
| 그리디 (Greedy)            | 가장 큰 두 수 선택  | O(1)      | 정렬된 경우에만 사용 가능, 매우 빠름 |

![image](https://github.com/user-attachments/assets/75f834fb-198c-4043-bde0-a67df64d4c4f)

# 재귀
- 자신을 정의할 때, 자기 자신을 참조하는 것

## 재귀함수를 사용하는 이유
- 변수의 사용을 줄여 프로그램을 더 간결하고 이해하기 쉽게 만들 수 있음.

![image](https://github.com/user-attachments/assets/3ef1ddcf-7bd3-4f43-b9c9-295a9dddf053)

![image](https://github.com/user-attachments/assets/dcf66f03-4ef4-4830-814e-5752f627dee2)


# 정렬

![image](https://github.com/user-attachments/assets/bd86cc89-05eb-4868-ae39-eabf0c5f65bc)
퀵 정렬이 자주 쓰임

| 정렬 알고리즘 (Algorithm)      | 언제 사용하면 좋은가?                                                                 |
|-------------------------------|--------------------------------------------------------------------------------------|
| 버블 정렬 (Bubble Sort)       | - 공부용, 아주 작은 데이터만 정렬할 때<br>⚠️ 실제 사용은 거의 없음                   |
| 선택 정렬 (Selection Sort)    | - 교환 횟수가 적은 게 중요할 때<br>⚠️ 데이터가 많으면 번보 효율적이지 않음           |
| 삽입 정렬 (Insertion Sort)    | - 데이터가 거의 정렬되어 있는 경우<br>⚠️ 작은 데이터에 빠름                         |
| 합병 정렬 (Merge Sort)        | - 안정 정렬이 필요할 때, 데이터 양이 많을 때<br>⚠️ 외부 정렬(파일 정렬)에도 적합     |
| 퀵 정렬 (Quick Sort)          | - 대부분의 경우 빠름!<br>⚠️ 최악의 경우 O(n²)이 필요 (이미 정렬된 경우 등)         |
| 힙 정렬 (Heap Sort)           | - 시간 복잡도 O(n·log n)이 보장 필요할 때<br>⚠️ 메모리 제약이 적고 in-place 정렬 가능 |

https://subinze.tistory.com/14

![image](https://github.com/user-attachments/assets/22bf465f-274e-4cf8-bc86-a405660b1713)

# 버블 정렬 (Bubble Sort)

- **원리**: 인접한 두 수를 비교해서 큰 수를 뒤로 보낸다 (풍선처럼 큰 수가 떠오름)  
- **초기 상태**: `8, 5, 6, 2, 4`

| 단계 | 배열 상태         | 설명                                  |
|-----:|-------------------|---------------------------------------|
| 1    | `[5, 6, 2, 4, 8]` | 8이 맨 뒤로 밀려남 (1회전 완료)        |
| 2    | `[5, 2, 4, 6, 8]` | 6이 맨 뒤에서 두 번째로 배치           |
| 3    | `[2, 4, 5, 6, 8]` | 계속해서 작은 수가 앞으로 이동        |

**최종 결과**: `[2, 4, 5, 6, 8]`

![image](https://github.com/user-attachments/assets/2c712f9b-f62a-48d7-817a-76e43c1e08ec)

## 합병 정렬

- **분할 (Divide)**  
  정렬되지 않은 리스트를 **각각 하나의 원소만 포함하는 n개의 부분 리스트**로 분할  
  > (원소 개수가 1인 리스트는 이미 정렬된 것으로 간주)

- **병합 (Merge)**  
  부분 리스트가 하나만 남을 때까지 **가장 작은 요소끼리 비교하며** 두 부분 리스트를 합병  
  > 매 단계마다 정렬된 부분 리스트를 생성

- **완료 (Result)**  
  마지막으로 남은 단일 리스트가 **전체가 정렬된 최종 결과**가 된다

![image](https://github.com/user-attachments/assets/6b100a49-756b-4ff5-828e-e09f3ba1ae9d)

## 퀵 정렬

![image](https://github.com/user-attachments/assets/bcf2d60a-dfe3-4511-8d08-08aa5a71cb1c)

![image](https://github.com/user-attachments/assets/339c793c-001f-41d7-9edf-f0a0cb02f196)

## 힙 정렬
ex) 이진 트리, 힙
- **최대 힙 구성 (Build Max-Heap)**  
  - 최대 힙(Max-Heap)이란 **부모 노드의 값이 자식 노드의 값보다 큰** 완전 이진 트리 구조

- **정렬 단계** (힙 사이즈 > 1 동안 반복)  
  1. **루트(최대값)**와 **마지막 요소**를 교환  
  2. 힙의 크기를 1 줄임  
  3. 줄어든 힙에서 **최대 힙**을 재구성  

- **종료 조건**  
  - 힙의 크기가 1이 되면, 전체 배열이 정렬된 상태가 됨
  https://m.blog.naver.com/ndb796/221228342808

![image](https://github.com/user-attachments/assets/5760378b-cf31-463e-811a-fe214a34ee29)

# 투 포인터

- **정의**  
  포인터 두 개를 사용해 배열 내 두 위치를 기록하며 문제를 해결하는 기법

- **적용 상황**  
  1차원 배열을 순차적으로 접근하거나 구간을 탐색해야 할 때

- **포인터 이름 예시**  
  - `(s, e)`  
  - `(st, en)`  
  - `(start, end)`  
  - `(l, r)`  
  - `(left, right)`

- **시간 복잡도**  
  일반적으로 O(N)

- **동작 예시**

  ```text
   s         e
   ↓         ↓
  [10, 20, 30, 40]



![image](https://github.com/user-attachments/assets/5b02c7c5-7744-4e89-8ac6-0f99e57f43b1)

![image](https://github.com/user-attachments/assets/35255317-59aa-4e0d-9afd-b6966422bb0c)

# 슬라이딩 윈도우

- **이름 유래**  
  창문을 밀며 닦듯이, 고정 크기의 창(window)을 밀어 가며 처리

- **정의**  
  고정된 크기의 윈도우(window)가 배열(또는 문자열) 위를 이동하며  
  윈도우 내의 데이터만 사용해 문제를 해결하는 기법

- **투 포인터와의 차이**  
  - 투 포인터는 두 포인터 사이 간격이 가변적일 수 있지만  
  - 슬라이딩 윈도우는 **윈도우 크기가 고정**되어 두 포인터가 항상 일정 거리를 유지하며 함께 이동

- **시간 복잡도**  
  일반적으로 O(N)

- **동작 예시**

  ```text
  배열: [a, b, c, d, e, f, g]
       ┌─────┐
       │ a b c │  ← 윈도우 크기 3
       └─────┘
         ┌─────┐
         │ b c d │  ← 한 칸 슬라이드
         └─────┘
           ┌─────┐
           │ c d e │
           └─────┘
           … 계속 반복 …


